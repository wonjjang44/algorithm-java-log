# p12915 - 문자열 내 마음대로 정렬하기

- 링크: https://school.programmers.co.kr/learn/courses/30/lessons/12915
- --

## 요약
문자열 배열과 정수가 주어질 때,<br/>
각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬한 배열을 리턴하는 메서드 구현
- --

## 접근
- String[]의 n번 째 인덱스에 해당하는 문자 출력하기(charAt)
- 뽑아낸 문자들을 Map에 담는다.(key = 인덱스에 해당하는 문자 / value = 넘겨받은 문자열)
  - 입력받은 순서를 보장하기 위해 LinkedHashMap 사용
- 문자가 전부 동일하다 => 원본 배열 사전적 오름차순 정렬
- 문자가 2개만 동일하다 
  - 다른 문자와 같은 문자들을 비교하여 우선 정렬 후 같은 문자들은 사전적 오름차순 정렬
- -- 

## 회고
- 실행했더니 두 번째 케이스에 걸림.
  - 서로 같은 문자라면 두 번째 문자로 덮어씌워지기 때문에 null이 뜨고 있음
  - 문자가 서로 같을 경우의 조건을 추가해야 할 듯
    - 잘 안 됨
    
  <br/>
- 아무리 봐도 접근 자체가 잘못된 것 같음. 문자가 같을 경우를 배제함. 다시 접근해보자
  - strings 자체를 정렬
  - 비교 기준을 charAt(n) 비교
  - 같다면 s 전체 비교(사전적 오름차순 정렬)

- 해당 문제를 n에 해당하는 인덱스에 위치한 값들이 원본 값들을 가리킬 수 있는가 라는 것에 대하여 생각하다보니 Map을 사용하려고 함.
- 하지만 아직 Map  자료구조에 대하여 얇게 알고 있어 해당 방법으로 실패함.


- 선택정렬 방법 택함(효율은 안 나와도 정렬 알고리즘에 대하여 익숙해지기 위함)
  - 선택정렬 => i번째 자리에 존재하는 것 중 최소를 가져온다.
  - 문자열 배열 length -1 을 한 이유는 마지막 인덱스는 비교할 필요가 없기 때문(이미 최솟값인데 또 비교할 필요가 없으니까)
  - 최초 기준점으로 잡기위해 i(index값)을 선언한다. => int initVal = i;
  - 내부 for문은 i + 1부터 시작. => i부터 시작하면 항상 같은 값을 가진 값들을 비교하여 true 고정됨. 불필요한 비교를 줄이기 위함
  - a => 최솟값 / b => 비교할 대상
    - b가 a보다 작다면 최소 후보(a)를 b로 변경
  - b가 a보다 작다면 flag 값을 true
  - b와 a가 같다면 사전상 비교(compareTo() 메서드 사용)
    - b.compareTo(a) < 0 => b가 a보다 앞이면 음수, 즉 b가 a보다 작다
  - 더 작은 값을 찾으면 initVal 값 변경 => initVal = j;
  - 이후 스왑

