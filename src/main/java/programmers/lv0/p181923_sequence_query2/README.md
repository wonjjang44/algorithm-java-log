# p181923 - 수열과 구간 쿼리2

- 링크: https://school.programmers.co.kr/learn/courses/30/lessons/181923
- --

## 요약
정수 배열 arr와 2차원 정수 배열 queries이 주어질 때,<br/>
queries의 원소는 각각 하나의 query를 나타내며, [s, e, k] 꼴.<br/>
query마다 순서대로 s <= i <= e 인 모든 i에 대하여 k 보다 크면서 가장 작은 arr[i]를 찾아야 함.
특정 쿼리에 답이 존재하지 않는다면 -1 리턴
- --

## 접근
- 내가 이해한 바로는 arr[i]는 s보다 크거나 같고, e보다 작거나 같은 값이며,<br/>
  앞 조건을 만족하는 arr[i] 값은 k보다 커야함(초과).
- 이 값들 중 Min 값을 구하면 된다 라고 이해.
- 최초 이차원 배열을 순회하면서 각 일차원 배열의 원소를 뽑아낸다.
- arr[i]값이 s와 e 값 사이에 충족하는지, k보다 큰지 비교한다.
- 값이 1개가 아닌 N개라면 둘 중 Min 값을 뽑아내어 배열에 담는다.
- 만약 조건에 해당하는 값이 0개라면 -1을 배열에 담는다.
- -- 

## 회고
- 최솟값 뽑아내는 문제인 듯
- 문제를 잘못 이해함...
  - i는 s보다 크거나 같고 e보다 작거나 같아야 하며, 동시에 arr[i]가 k보다 커야함(초과)
  - 즉, s <= arr[i] <= e && k < arr[i]가 아니라
  - s <= i <= e && k < arr[i] 임.
- 위 조건을 if문으로 뺐는데 차라리 for문 조건식에 for(int i = s; i <= e; i++) 라고 하는 것이 
  조금 더 최적화 된 것 같음
- 최솟값은 비교 기준이 되는 큰값을 선언한 뒤, 해당 값과 초기에 비교하여 나가는 방식으로 구함
  - Max.min() 메서드 사용해도 될 듯

- 도움을 받은 문제이므로 다시 한 번 더 풀어봐야 함